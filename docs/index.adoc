= Network Communication and FMI 3.0, v1.0
:doctype: book
:imagesdir: images
:sectnums:
:sectnumlevels: 5
:toc: left
:toc-title: Contents
:toclevels: 5
:xrefstyle: short
:docinfo: shared
:stylesheet: fmi-spec.css
:stem: latexmath
:source-highlighter: highlightjs
:nofooter:
:favicon: images/favicon.ico
:icons: font

This layered standard on top of FMI 3.0, defines how to describe and simulate network signals as input and output variables of an FMU.

{empty} +
{empty}

Copyright (C) 2022 The Modelica Association Project FMI.

This document is licensed under the Attribution-ShareAlike 4.0 International license.
The code is released under the 2-Clause BSD License.
The licenses text can be found in the https://raw.githubusercontent.com/modelica/fmi-standard/master/LICENSE.txt[LICENSE.txt] file that accompanies this distribution.

{empty}

== Introduction

=== Intend of this Document

Automotive CAN, LIN, FlexRay, CAN FD, CAN XL and Ethernet are network technologies that have been applied successfully over many years by all automotive OEMs world wide.
Virtualizing electronic control units (ECUs) and then simulating multiple such virtual ECUs requires connecting them using a virtual version of these network technologies.

This layered standard defines what input and output variables and which FMI 3.0 features are used and how to emulate a transport layer for such network traffic.

There are mainly two base use cases envisioned here:

 - Physical signal abstraction ("high cut") to simply transport physical signal values between virtual ECUs. +
   The network properties are largely idealized: infinite bandwidth, zero-delay etc.
   Signals, groups of signals and their properties (e.g. units) are usually derived from (existing and validated) standard network topology description formats (such as DBC, LDF, Fibex and ARXML).
 - Network abstraction ("low cut") to facilitate MicroController Abstraction Layer (MCAL) emulations. +
   This transport layer emulation allows anything from idealized to more detailed network simulations, including bandwidth restrictions, message arbitration and delays and it forwards the network payloads using binary variables.
   The "low cut" abstraction layer is meant to allow virtualized MicroController Abstraction Layer (MCAL) driver implementations, including feedback from the physical drivers about send timing, rejection or network errors. Since the Network abstraction Layer is protocol-independent, it can also be used for the simulation of non-automotive control units, e.g. from the field of industrial automation.

In the simplest use case, the importer does not need to know about the special network semantics of certain variables of an FMU; it simply forwards variable values between 2 FMUs according to the FMI standard (<<multiOutput,with one exception noted at the end of the document>>).
Only when more than two FMUs are connected to a single network a bus simulation component is required to merge and then forward the network interface semantics of the different variables from multiple output variables to multiple input variables.

See the following image describing three potential architectures for connecting two or more networked virtual ECUs packaged into FMI 3.0 FMUs:

.3 ways to connect virtual ECU network variables.
[#vECU-network-architectures]
image::architecture.svg[width=80%, align="center"]

=== How to Read This Document

Conventions used in this document:

 - Non-normative text is given in square brackets in italic font: [Especially examples are defined in this style.]
 - The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 (regardless of formatting and capitalization).

== Common Concepts
Physical signal abstraction ("high cut") and Physical network abstraction ("low cut") layers are similar in many respects and can be translated into one another using the <<NetworkDescriptionFile,network description files>>.
Depending on the export tool, one of the abstraction layers is more "natural" to the FMU, while the other might have to be emulated with additional internal effort or an adapter (FMU) could be used.
Importers on the other hand rarely require both abstraction layers for system level compositions, because the engineering tasks define the required level of abstraction for the network communication.
FMUs may choose to only support one abstraction layer providing only the corresponding variables.
However, for versatility, having FMUs capable of communicating on both abstraction layers is more convenient for users.

_[FMUs providing both abstraction layers can deduce from the fmi3Set() and fmi3Get() calls they receive, which abstraction layer the importer is using.]_

Since network communication is not continuous but time discrete, FMI 3.0 clocks are used to indicate when signals and/or frames are sent or received.
All signal and frame variables are clocked variables.

FMI 3.0 terminal definitions in the `terminalsAndIcons.xml` for each level of grouping (networks, frames and PDUs) allow system composition tools without knowledge of the network description format to semantically group signals.
To uniquely map between the FMU variables and the network variables, FMU variable names are structured, e.g. `BusName::FrameName::PDUName::SignalName`.

// TODO AJ: explanation of clock and binary (check names!) variables for low cut; clock type influences and flexibilities; not use of nextEventTime

All variables have structured names that indicate how these variables are related and to which abstraction layer they belong.
For the high cut, variables represent signals and their clocks.
For the low cut, variables represent frames and their clocks.
Input and output variables show if these variables belong to signals or frames that are received or sent, respectively.
Input clocks must be triggered and are connected by the importer to their corresponding output clocks of potentially different clock types.
For example, a periodic output clock indicates that the FMU can only send signals or frames periodically, while a countdown clock indicates that the FMU can send signals at varying time steps.

Using output clocks of different types allows simulations with different timing accuracy and performance.
These clocks allow the FMU to specify the next send event efficiently and accurately, the importer will trigger these clocks according to these clock specifications as accurately as it can.

_[The alternative of using `nextEventTime` would force epsilon matching of event times.]_

// TODO AJ: Fix and variable step size influence on buffering of transport-layer events and their binary variables
//  -> high cut is different: no buffering possible: each send must be handled as Event
For any periodic (fixed-time) sending of messages, multiple message sends fall into one `doStep`.
While high-cut signal variables will miss all but the last value sent, low-cut frame variables will buffer all payloads inside their value.

If an FMU represents network nodes that are both sender and receiver of a signal, the receiver role will be removed from the FMU interface to allow the signals to have a unique role as output and the reading of such outputs must be handled internally to the FMU.

_[The FMI standard requires a variable to be either input or output.]_

// TODO: is this correct? does that also work for network simulations? how else to solve this unique-variable-name requirement?

// TODO AJ: structure of binary variable: event code plus parameters, potentially multiple parameter sets as send and confirm events must be buffered

While the values and semantic of the clock variables are clear, the binary frame variables are opaque to the importer but have internal structure to implement the transport layer of the specific network technology, see <<FrameVariable>>.
Frame variables do not just transport the network-specific payload, but also carry protocol-specific status information.
Status information allows, for example, the MCAL emulation of a virtual ECU to report back to the COM-stack about success or errors of a send request.

=== System Compositions [[SystemCompositions]]
Overall, this standard considers three possible communication architectures for bus communication.
It should be explicitly noted at this point that the FMUs for integration in the respective use case do not have to be different, so that the same FMU can be integrated across all three communication architectures.

==== Direct Communication [[DirectCommunication]]
The first option is to use a normal FMU importer. Within this configuration, the FMU importer does not require any special features for simulating buses, apart from supporting FMI variables, clocks and terminals. The figure below illustrates the direct communication of two FMUs:

.Direct communication of two FMUs.
[#figure-direct-communication-of-two-fmus]
image::architecture_direct_connection.svg[width=80%, align="center"]

Direct bus communication is limited to exactly two FMUs. The simulation of more than two FMUs is therefore not intended. The bus simulation is also only idealized, so that the simulation of bus transmission times or arbitration, for example, is not supported. Such an ideal network differs from physical networks in the following ways (and potentially others):

 * Network frame arbitration: frames are sent on the wire according to network-specific priority rules. +
   Here all frames are transmitted at the same time without delay.

 * Network congestion/bandwidth: too many network frames sent for the bandwidth of the network. +
   Here the network has infinite capacity. +
   If network properties are required, a bus simulation component must be added or included with the importer.

 * Protocol functions of higher levels: i.e. CAN request for retransmit is a specific protocol function. +
   Here such specialties must be handled by the first layer inside the FMU.

 * Incoming buffer overflow: when an ECU receives more frames than its buffer can hold. +
   Here the FMU will receive all frames, regardless of buffer size and would need to handle those limitations internally.

==== External Bus Simulation FMU [[ExternalBusSimulationFmu]]
Within the second application, the FMUs are integrated via an additional FMU, the so-called Bus Simulation FMU. Within this configuration, the FMU importer does not require any special features for simulating buses, apart from supporting FMI variables, clocks and terminals. The figure below shows two FMUs which are connected to a specific Bus Simulator FMU. The figure below shows two FMUs which are connected to a specific Bus Simulator FMU. The total of three FMUs are executed on a standard importer:

.Bus simulation by using an external Bus Simulation FMU.
[#figure-external-bus-simulation-fmu]
image::architecture_bus_simulation_fmu.svg[width=80%, align="center"]

This type of communication allows the simulation of all bus features, such as arbitration or the simulation of timing. The limitation of the supported bus features cannot be specified explicitly in the case shown, but refers to a specific implementation of a Bus Simulator FMU.

This communication architecture enables complex bus simulations to be implemented on lightweight FMU importers. An n:m bus communication of several FMUs is also permitted. Depending on the needs, it may be necessary to dynamically provision the Bus Simulator FMU so that it provides the appropriate number of inputs and outputs to allow all FMUs to be connected.

==== Bus feature integrated FMU Simulator [[BusFeatureIntegratedFmuSimulator]]
In the third variant of the communication architecture, the Bus Simulations FMU is built directly into the respective FMU importer. The supported bus features are analogous to <<ExternalBusSimulationFmu, the External Bus Simulation FMU use case>>. The corresponding limitations regarding the behavior of the bus simulation are importer-specific. The following figure illustrates two FMUs, which integrated to an importer that directly supports this standard an needs no further external Bus Simulation FMU:

.Bus simulation by using an Bus Simulation FMU, which is directly integrated into the specified importer.
[#figure-bus-feature-integrated-fmu-simulator]
image::architecture_bus_simulation_importer.svg[width=80%, align="center"]

This communication architecture enables the realization of complex bus simulations, which also want to integrate other, for example manufacturer-specific, formats into a bus simulation.

=== Timing Aspects

#TODO#

== Physical signal abstraction ("high cut")

=== Overview

=== Variables

This section explains the different variable types used to carry network traffic through FMI input and output variables.

==== Signal Variables

To define the signal abstraction layer (or "high cut"), signal variables are defined.

A signal variable carries the physical value of a network signal normally packaged inside a PDU or frame.
The unit definition of the variable must match the one defined in the <<NetworkDescriptionFile>>.

Each network signal must be listed as <<TerminalMemberVariable>> of its corresponding <<PDUTerminal>>.

In case multiplexed signals are present in a frame/PDU: all signals are present, but only the active signal according to the multiplex switch signal contains a valid value, all inactive variables have undefined values _[those values could even be outside their specified min-max range without fault]_.

Generally, signal variables are optional, but they must either be all missing or all present to clearly indicate support for the signal abstraction layer.

All signal variables are clocked to indicate when exactly they have been sent, see <<ClockVariableHighCut>>.


==== Clock Variables [[ClockVariableHighCut]]

// TODO AJ: Add description of Event Mode handling here and how the countdown clock pre-schedules events into the future for performance reasons


In order to use FMU input and output variables as transport layer for networks, input and output clocks are used.
Such a clock is scheduled by the sending FMU to indicate the transmission of the corresponding frame or frames.

The output clock type, periodic or aperiodic, is defined by the sending FMU.
This allows the FMU (or better the exporting tool) to balance the accuracy and performance of its network communication:

 - While aperiodic clocks allow very accurate network simulations, frequently entering Event Mode will reduce the network simulation speed.
 - Using periodic clocks and buffering the frames to be transmitted reduces the number of Event Modes required and speeds up the simulation at the cost of simulation accuracy.
 - One could use (structural) parameters to define the accuracy of aperiodic clocks, allowing control of the simulation accuracy and performance with the same FMU.
 - The input clocks shall be triggered clocks.

The importer will then connect and merge output clock activations, even those of different clock types, and forwards them to the input clocks, as required by the network semantics.

All signal variables are clocked variables.
Signal variables belonging to frame `BusName::FrameName` are triggered by the clock `BusName::FrameName_Clock` and all these variables and their corresponding clock must share the same `causality` (`input` or `output`).

=== Network Description Files [[NetworkDescriptionFile,network description file]]

// TODO AJ: remove old requirements for network description files (not needed anymore): make it optional

Standardized <<NetworkDescriptionFile,network description files>> can be shipped with each FMU to describe properties of signals and frames, such as signal units, frame composition and trigger conditions.
These <<NetworkDescriptionFile,network description files>> must be placed into the `/extra/org.fmi-standard.fmi-ls-bus` folder.
DBC, LDF, Fibex and ARXML files are allowed, e.g. `Powertrain.dbc`.
The case sensitive root name of the <<NetworkDescriptionFile>> must be used as network identifier in the bus terminal type and prefix in the variable names.

Multiple files can be specified, each one defining one network used by the FMU.
This standard does not support composing one network from multiple <<NetworkDescriptionFile,network description files>>, even if using internal include mechanisms, it rather enforces the rule: one network - one file.

It is recommended to use ARXML over DBC files for CAN whenever possible, because the DBC standard lacks some key frame/PDU properties that were added only later using non-standard extensions with different dialects in use.

This document does not address potential open points of these description formats, it is assumed that such ambiguities will be handled elsewhere (e.g. message timing in the DBC format).
This document does not address IP protection or copyright issues.
These are technical and legal issues that need attention from standardization bodies of the referenced description formats, tool vendors and end users.

=== Terminal Definitions

==== Bus Terminal [[BUSTerminalHighCut,bus terminal]]

Each network connected to the FMU must be described in `icons/terminalsAndIcons.xml` as a `<Terminal>` element of `<fmiTerminalsAndIcons><Terminals>` that wraps all <<FrameTerminal,frame terminals>>.
The attribute `name` of the `<Terminal>` must match the root name of its <<NetworkDescriptionFile>> if it exists
_[e.g. `Powertrain`, if the file is `/extra/org.fmi-standard.fmi-ls-bus/Powertrain.dbc`]_.
In any case, the attribute `name` of the `<Terminal>` must be consistent with the `BusName` component of all its corresponding signal, frame and clock variables.

Attribute definitions::
 * `terminalKind` must be set to `bus`.
 * `matchingRule` must be set to `bus`.
 * `name` is the network name, e.g. `Powertrain`, see <<ExampleHighCut>> and constraints above.

Element definitions::
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be one `<Terminal>` element per network frame described in the <<NetworkDescriptionFile>>, if their signal and lock variables are present in the `modelDescription.xml`.

Annotation element::
 * There must be an `<Annotation>` element defining which node or nodes (as comma-separated list without spaces) of the <<NetworkDescriptionFile>> are wrapped inside the FMU.
If the combination of nodes specified for this FMU turns a frame and its signals into both input and output because sending and receiving nodes are specified, only the sending (output) role will be defined in the FMU interface.
Receiving such frames must then be handled internally to the FMU.

==== Frame Terminal [[FrameTerminal,frame terminal]]

Each frame listed in the <<NetworkDescriptionFile>> must be an element of its corresponding <<BUSTerminalHighCut>>.

Attribute definitions::
 * `terminalKind` must be set to `frame`.
 * `matchingRule` must be set to `bus`.
 * `name` must match the frame name as defined in the <<NetworkDescriptionFile>> in `/extra/org.fmi-standard.fmi-ls-bus`.

Element definitions::
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be one <<PDUTerminal>> element per PDU of this frame.
 * There must be one `<TerminalMemberVariable>` for the clock this frame is connected to.
   The name of this variable is composed as <<ClockVariable,`BusName::FrameName_Clock`>>, e.g. `Powertrain::tcuSensors_Clock`.

The <<TerminalMemberVariable>> must have the same causality as all variables referenced in the <<PDUTerminal,PDU Terminals>> included here.

==== PDU Terminal [[PDUTerminal,PDU terminal]]

Each PDU listed in the <<NetworkDescriptionFile>> must be an element of its corresponding <<FrameTerminal>>.

Attribute definitions::
 * `terminalKind` must be set to `pdu`.
 * `matchingRule` must be set to `bus`.
 * `name` must match a PDU name of the <<NetworkDescriptionFile>> in `/extra/org.fmi-standard.fmi-ls-bus`, if given.
    For network types not natively referencing a "PDU", like CAN, a synthetic PDU with the same name as its frame is inserted.

Element definitions::
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be no `<Terminal>` element.
 * There must be one `<TerminalMemberVariable>` per <<TerminalMemberVariable,signal>> of this PDU.

All <<TerminalMemberVariable,`TerminalMemberVariables`>> must have the same causality of either `input` or `output`.

==== Terminal Member Variable for Signals [[TerminalMemberVariable,Terminal Member Variable]]

<<PDUTerminal,PDU terminals>> list all the contained signals as `<TerminalMemberVariable>`.

Attribute definitions::
 * `variableName` refers to the input or output variable name of the FMU and to enforce uniqueness is built as follows: `BusName::FrameName::PDUName::SignalName`, e.g. `Powertrain::tcuSensors::tcuSensors::vCar`.
    These variables represent the signal abstraction layer ("high cut").
 * `memberName` is the `SignalName` as given in the <<NetworkDescriptionFile>>, e.g. `vCar`, if given.
    This is redundant information but simplifies signal name extraction.
 * `variableKind` is `signal`.


=== Example [[ExampleHighCut,ExampleHighCut]]

The following excerpts from files are used throughout this document as examples and should illustrate how the different concepts relate.

The following partial DBC file lists merely the CAN message (frame) structure.
Signal trigger conditions are not included because they have no bearing on this standard.

.Example Powertrain.dbc file
[#Powertrain.dbc]
[source, C]
----
...
BO_ 256 tcuSensors: 4 TCU
 SG_ vCar :          0|16@1- (32,0)  [-500|500] "km/h" ECU
 SG_ oilTemp :      16|9@1-  (2,50)  [-50|150]  "Grad C" ECU

BO_ 257 tcuState: 2 TCU
 SG_ state :         0|2@1+  (1,0)   [ 0|2] "-" ECU
 SG_ gear :          2|4@1-  (1,0)   [-2|6] "-" ECU
 SG_ targetGear :    6|4@1-  (1,0)   [-2|6] "-" ECU

BO_ 512 ecuState: 4 ECU
 SG_ accelPedal :    0|8@1+ (2,0)   [0|100]   "%" TCU
 SG_ k15 :           8|1@1+ (1,0)   [0|1]     "-" TCU
 SG_ oilTemp :       9|9@1- (2,50)  [-50|150] "Grad C" TCU
 SG_ radiatorTemp : 18|9@1- (2,50)  [-50|150] "Grad C" TCU
...
----

The `modelDescription.xml` excerpt listed below shows which variables would exist for the `Powertrain.dbc` shown above.

.Example modelDescription.xml for ECU node
[#modelDescriptionHighCut.xml]
[source, XML]
----
include::examples/X_network4FMI_modelDescription_highCut.xml[]
----

The following file shows the `<Terminal>` definition representing the network and frame structure defined with `Powertrain.dbc` above.

.Example terminalsAndIcons.xml file
[#terminalsAndIconHighCut.xml]
[source, XML]
----
include::examples/X_network4FMI_terminalsAndIcons_highCut.xml[]
----

== Network Abstraction ("low cut")

#TODO dSPACE# 

=== Overview 

#TODO dSPACE# 

.Example for network simulation.
[#figure-example-network-simulation]
image::bus_simulation_example.svg[width=80%, align="center"]

=== Variables

This section explains the different variable types used to carry network traffic through FMI input and output variables.

==== Communication Variables [[CommunicationVariable, Communication Variables]]

// TODO AJ: this needs to change completely: This is now "Data"

To define the network abstraction layer (or "low cut"), controller variables are used.

A communication variable is of type `fmi3Binary` and contains one or more binary operations, as sent or receive by the FMU.
There are two such communication variables per bus controller: an input and an output.
The names of these communication variables are defined as `BusName::Rx_Data` and `BusName::Tx_Data`, e.g. `Powertrain::Rx_Data` and `Powertrain::Tx_Data` (see <<ExampleLowCut, Example>>).

Both input and output variables must be listed as members of its corresponding <<BUSTerminalLowCut>>.

The senders of network frames can chose how many frames are buffered and/or for how long frames are buffered before activating an output clock to trigger the actual sending of these frames.
This allows senders to trade accuracy for speed: buffering more and interrupting the simulation less will lead to faster simulations, but less accurate timing of the network communication, see <<ClockVariableLowCut>>.

// TODO all: MIME types: org.fmi-standard.fmi-ls-bus.v1.[CAN|CANFD|LIN|FlexRay|Ethernet|SPI] -- anything missing? names good?

The following table lists the names of MIME types used for controller variables:

[#table-mime-types]
[cols="4,5",options="header"]
|====
|MIME type name
|Description

|org.fmi-standard.fmi-ls-bus.v1.Can
|Binary variables simulating the automotive CAN network including CAN, CAN FD and CAN XL

|org.fmi-standard.fmi-ls-bus.v1.Lin
|Binary variables simulating the automotive LIN network

|org.fmi-standard.fmi-ls-bus.v1.FlexRay
|Binary variables simulating the automotive FlexRay network

|org.fmi-standard.fmi-ls-bus.v1.Ethernet
|Binary variables simulating the automotive Ethernet network

|org.fmi-standard.fmi-ls-bus.v1.Spi
|Binary variables simulating the automotive SPI network

|====

As in the table above shown the version of a specified bus type is integrated within the MIME type. The MIME type and the associated versioning ensure that only compatible bus types can be connected to each other. The version number marks the set of available operations. Only the major version is included by the specified MIME type. The versioning follows the rules of https://semver.org/[Semantic Versioning 2.0.0].

The content of a binary variable is any number of operations, including none.

An operation is always defined by the following attributes:

* Name: The name of the specific operation for example _Transmit_ or _Confirm_.
* OP Code: The OP Code defines the a unique value for every kind of operation. It consists of one byte in length and is defined for every bus type by this standard.
* Arguments: The arguments of the respective operation follow the OP Code. Each argument and the specific argument length is defined for each operation within this standard.
* Repeated: One bit within the OP Code if an operation can be exists more than one time in the specific `fmi3Binary` variable. 

The following table shows an example for an operation definition.
The name is _OperationName_ and it contains three arguments _Arg1_ (2 bytes long), _Arg2_ (3 bytes long), _Arg3_  (4 bytes long).
The operation can be repeated:

[cols="1,1,1,1,1,1"]
|====
.2+h|Frame type
5+h|Frame content

h|OP Code
3+h|Specific content
h|Repeated 

|OperationName
|0x01
|2 byte Arg1 
|3 byte Arg2
|4 byte Arg3
|Yes

|====

The OP code contains an operation byte and encodes the size of the OP specific content field length (except Transmit frames with 0xef if frame has variable length with its own length field) and a repeat-bit (most significant bit of the second byte).
The following table shows the OP Code structure:

// TODO all: the follow could be compressed into a single byte, but would that help?

[#table-opcode-structure]
[cols="4,3,3"]
|====
h|Type
h|Repeat content
h|Length

|8 bit
|1 bit
|7 bit

|====

// TODO all: we need a table here with network and message errors here

==== Clock Variables [[ClockVariableLowCut]]

// TODO AJ: Add description of Event Mode handling here and how the countdown clock pre-schedules events into the future for performance reasons

In order to use FMU input and output variables as transport layer for networks, input and output clocks are used.
Such a clock is scheduled by the sending FMU to indicate the transmission of the corresponding frame or frames.

The output clock type, periodic or aperiodic, is defined by the sending FMU.
This allows the FMU (or better the exporting tool) to balance the accuracy and performance of its network communication:

 - While aperiodic clocks allow very accurate network simulations, frequently entering Event Mode will reduce the network simulation speed.
 - Using periodic clocks and buffering the frames to be transmitted reduces the number of Event Modes required and speeds up the simulation at the cost of simulation accuracy.
 - One could use (structural) parameters to define the accuracy of aperiodic clocks, allowing control of the simulation accuracy and performance with the same FMU.
 - The input clocks shall be triggered clocks.

The importer will then connect and merge output clock activations, even those of different clock types, and forwards them to the input clocks, as required by the network semantics.

Both controller variables are clocked variables.
The input frame variable `BusName::Rx_Data` is clocked by the clock variable `BusName::Rx_Clock`, both with `causality` set to `input`.
The output frame variable `BusName::Tx_Data` is clocked by the clock variable `BusName::Tx_Clock`, both with `causality` set to `output`.
Both clock variables must also be listed as member of its corresponding <<BUSTerminalLowCut>>.

// TODO AJ: Add description of Event Type and their respective parameters and applicability to the different protocol types (mimic table)

// TODO all: Should we mandate that all output clock types must be the same? Or should we allow the exporter to mix clock types for the different abstraction layers, or even for the different frames? Since different FMUs might use different clock types anyway, an importer needs to handle the mixed case anyway. Any other reason to be more strict here?

==== Example [[ExampleLowCut,ExampleLowCut]]

The following excerpts from files are used throughout this document as examples and should illustrate how the different concepts relate.

.Example modelDescription.xml for ECU node
[#modelDescriptionLowCut.xml]
[source, XML]
----
include::examples/X_network4FMI_modelDescription_lowCut.xml[]
----

The following file shows the `<Terminal>` related definition:

.Example terminalsAndIcons.xml file
[#terminalsAndIconLowCut.xml]
[source, XML]
----
include::examples/X_network4FMI_terminalsAndIcons_lowCut.xml[]
----

=== Terminal Definitions
This section defines terminals for network abstraction or low cut.

==== Bus Terminal [[BUSTerminalLowCut,bus terminal]]
Each network connected to the FMU must be described in `icons/terminalsAndIcons.xml` as a `<Terminal>` element of `<fmiTerminalsAndIcons><Terminals>`. The attribute `name` of the `<Terminal>` must match the name of the specified bus controller _[e.g. the name of the CanController]_ within a low cut. If the specified V-ECU FMU contains more than one Controller, there shall be exactly one `<Terminal>` for each Controller.

Attribute definitions::
 * `terminalKind` must be set to `bus`.
 * `matchingRule` must be set to `bus`.
 * `name` is the controller name, e.g. `PowertrainController`, see <<ExampleLowCut, Example>> and constraints above.

Element definitions::
 * `BusName::Rx_Data` and `BusName::Tx_Data` and their clocks `BusName::Rx_Clock` and `BusName::Tx_Clock` are exposed in the `modelDescription.xml`, they must be listed as `<TerminalMemberVariable>` elements here.
 * There must be no `<TerminalStreamMemberVariable>` element.

The following figure shows a V-ECU FMU with four variables `Tx_Data`, `Tx_Clock`, `Rx_Data`, `Rx_Clock` that are aggregated to a `<Terminal>` named _Bus Terminal_: 

.Frame variables and terminals.
[#figure-frame-variables-terminals-lowcut]
image::bus_terminal.svg[width=80%, align="center"]

=== CAN, CAN FD, CAN XL
#TODO dSPACE#

* n:m Kommunikation
* Arbitrierung
* Acknowledge
* ...


Because CAN, CAN FD, CAN XL are supported by this standard, https://www.sae.org/[SAE J1939] is also indirectly supported.

==== Operations

#TODO dSPACE#

This section defines the allowed operations for CAN, CAN FD, CAN XL.
The following table provides an overview of all operations and specifies the position and length of the corresponding arguments, as well as the respective flow direction.

[#table-frame-contenct]
[cols="4,3,3, 3,3,3, 2,2,2, 2,2,2"]
|====
.2+h|Frame type
5+h|Frame content
6+h|Network type support

h|OP Code
3+h|Specific content
h|Repeated
h|CAN
h|CANFD
h|LIN
h|FlexRay
h|Ethernet
h|SPI

|NOOP
|0x0000
3+|---
|Single
|yes
|yes
|yes
|yes
|yes
|yes

|Transmit
|0x01ff
|4 byte Frame ID
|1 byte Data Length
|n byte Data
|Multiple
|yes
|yes
|yes
|yes
|yes
|yes

|Confirm
|0x0284
3+|4 byte Frame ID
|Multiple
|yes
|yes
|yes
|yes
|yes/no
|no

|Network Error
|0x0304
3+|4 byte error code
|Single
|yes
|yes
|yes
|yes
|yes
|no

|Frame Error
|0x0408
|4 byte Frame ID
2+|4 byte error code
|Single
|yes
|yes
|yes
|yes
|yes
|no

|Config Baud
|0x0504
3+|4 byte rate
|Single
|yes
|yes
|yes
|no
|no
|yes

|Config Clocks
|0x0604
3+|4 byte clock config
|Single
|no
|no
|no
|yes
|no
|yes

|Wakeup
|0x0700
3+|---
|Single
|no
|no
|no
|yes
|no
|yes

|Status
|0x0804
3+|??? 4 bytes ???
|Single
|?
|?
|?
|?
|yes
|?

|====

==== Sequence Diagrams
#TODO dSPACE#

=== LIN
#TODO dSPACE#

=== FlexRay
tbd

=== Ethernet

#TODO dSPACE#

=== Network Parameters [[NetworkParameters]]
tbd
// TODO all: define parameter names and their semantics influencing bus behavior and/or version of the fmi-ls-bus version (FMU declares them as parameters or structural parameters depending on internal mechanisms)

== Network Simulation [[NetworkSimulation]]
tbd

.Example network simulation architecture.
[#figure-example-network-simulation-architecture]
image::architecture_bus_simulation_importer.svg[width=80%, align="center"]

The figure above shows one example for a network simulation architecture.
The importer is able to handle FMU input and output variables with network semantics:
The importer merges output clock activations, output binary data and output signal variables and forwards the results to their corresponding input variables.

The accuracy/performance of the resulting network simulation can range from ideal (no bandwidth restriction, no arbitration, no network errors) to more realistic (with restricted bandwidth, message delay due to arbitration, network errors, error injection, ...).

== Known Limitations of this Standard

#TODO all#

This layered standard maps several network protocols onto co-simulation variables as transport layer simulating in many ways an ideal network.
Such an ideal network differs from physical networks in the following ways (and potentially others):

 * Network frame arbitration: frames are sent on the wire according to network-specific priority rules. +
   Here all frames are transmitted at the same time without delay.

 * Network congestion/bandwidth: too many network frames sent for the bandwidth of the network. +
   Here the network has infinite capacity. +
   If network properties are required, a bus simulation component must be added or included with the importer.

 * Protocol functions of higher levels: i.e. CAN request for retransmit is a specific protocol function. +
   Here such specialties must be handled by the first layer inside the FMU.

 * Incoming buffer overflow: when an ECU receives more frames than its buffer can hold. +
   Here the FMU will receive all frames, regardless of buffer size and would need to handle those limitations internally.

 * [[multiOutput]]Network protocols allow frames to be sent from more than one node. +
   Here this is also possible, with output variables for frames (and their signals) that are sent by more than one FMU.
   This requires the importer to handle the case when multiple source FMUs are sending the same frame.
   Importers must know how to handle this, just like they must know how to handle flow variables according to Kirchhoff's law.
